name: Private Release (tarball/SBOM + GHCR)

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write
  packages: write

concurrency:
  group: private-release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build-jetson-arm64:
    name: Build Jetson (arm64) tarball + push GHCR image
    # NOTE: Jetson/arm64 は self-hosted runner 前提でも可（Issue #1059）
    runs-on: [self-hosted, linux, arm64]
    env:
      PLATFORM: jetson-arm64
      VERSION_RAW: ${{ github.ref_name }} # e.g. v1.2.3
      IMAGE_NAME: totton-audio-system
    steps:
      - name: Resolve version strings
        id: vars
        run: |
          set -euo pipefail
          version_raw="${VERSION_RAW}"
          version="${version_raw#v}"
          echo "version_raw=${version_raw}" >> "${GITHUB_OUTPUT}"
          echo "version=${version}" >> "${GITHUB_OUTPUT}"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build gpu_upsampler_alsa (Release)
        run: |
          set -euo pipefail
          cmake -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_CUDA_ARCHITECTURES=87
          cmake --build build -j"$(nproc)"
          test -x build/gpu_upsampler_alsa

      - name: Assemble release package directory
        run: |
          set -euo pipefail
          VERSION="${{ steps.vars.outputs.version }}"

          pkg_dir="dist/package-${PLATFORM}"
          rm -rf "${pkg_dir}" dist/*.tar.gz
          mkdir -p "${pkg_dir}"/{bin,lib,web,scripts,data}

          # Licenses / attributions
          cp -f LICENSE LICENSE.ja.md NOTICE.md THIRD_PARTY_LICENSES.md "${pkg_dir}/"

          # Binaries
          cp -f build/gpu_upsampler_alsa "${pkg_dir}/bin/"

          # Optional shared libs produced by CMake (best-effort)
          while IFS= read -r -d '' sofile; do
            cp -f "${sofile}" "${pkg_dir}/lib/"
          done < <(find build -maxdepth 2 -type f -name "*.so*" -print0 || true)

          # Web UI / Control plane (runtime files)
          rsync -a --delete "web/" "${pkg_dir}/web/"

          # Runtime scripts (update, integration, etc.)
          rsync -a --delete "scripts/" "${pkg_dir}/scripts/"

          # Runtime data (coefficients/EQ/crossfeed) - align with Docker runtime
          mkdir -p "${pkg_dir}/data"
          rsync -a --delete "data/coefficients/" "${pkg_dir}/data/coefficients/"
          rsync -a --delete "data/EQ/" "${pkg_dir}/data/EQ/"
          rsync -a --delete "data/crossfeed/" "${pkg_dir}/data/crossfeed/"

      - name: Generate manifest.json + checksums.sha256 (inside tarball)
        run: |
          set -euo pipefail
          VERSION="${{ steps.vars.outputs.version }}"

          pkg_dir="dist/package-${PLATFORM}"
          manifest="${pkg_dir}/manifest.json"

          tree_hash() {
            local dir="$1"
            # Stable tree hash: sha256 of sorted "<filehash>  <path>" list
            (cd "${pkg_dir}" && \
              find "${dir}" -type f -print0 \
                | LC_ALL=C sort -z \
                | xargs -0 sha256sum \
                | sha256sum \
                | awk '{print $1}')
          }

          file_hash() {
            local file="$1"
            (cd "${pkg_dir}" && sha256sum "${file}" | awk '{print $1}')
          }

          build_time="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          git_sha="${GITHUB_SHA}"

          bin_hash="$(file_hash "bin/gpu_upsampler_alsa")"
          web_hash="$(tree_hash "web")"
          scripts_hash="$(tree_hash "scripts")"
          lib_hash="$(tree_hash "lib")"
          data_hash="$(tree_hash "data")"

          cat > "${manifest}" <<EOF
          {
            "version": "${VERSION}",
            "min_compatible": "1.0.0",
            "platform": "${PLATFORM}",
            "git_sha": "${git_sha}",
            "build_time": "${build_time}",
            "components": [
              { "name": "bin", "path": "bin/gpu_upsampler_alsa", "sha256": "sha256:${bin_hash}" },
              { "name": "lib", "path": "lib/", "sha256": "sha256:${lib_hash}" },
              { "name": "web", "path": "web/", "sha256": "sha256:${web_hash}" },
              { "name": "scripts", "path": "scripts/", "sha256": "sha256:${scripts_hash}" },
              { "name": "data", "path": "data/", "sha256": "sha256:${data_hash}" }
            ],
            "third_party_data_policy": {
              "opra": "not bundled (download/cache at first run)",
              "hutubs": "raw data not bundled (derived coefficients only, if any)"
            }
          }
          EOF

          # checksums.sha256: everything inside the tarball, excluding itself
          (
            cd "${pkg_dir}"
            rm -f checksums.sha256
            find . -type f ! -name "checksums.sha256" -print0 \
              | LC_ALL=C sort -z \
              | xargs -0 sha256sum > checksums.sha256
          )

      - name: Create tarball (magicbox-update-${VERSION}-${PLATFORM}.tar.gz)
        run: |
          set -euo pipefail
          VERSION="${{ steps.vars.outputs.version }}"
          pkg_dir="dist/package-${PLATFORM}"
          out="dist/magicbox-update-${VERSION}-${PLATFORM}.tar.gz"
          tar -C "${pkg_dir}" -czf "${out}" .
          ls -lh "${out}"

      - name: Upload tarball artifact
        uses: actions/upload-artifact@v4
        with:
          name: magicbox-update-${{ steps.vars.outputs.version_raw }}-${{ env.PLATFORM }}
          path: dist/magicbox-update-${{ steps.vars.outputs.version }}-${{ env.PLATFORM }}.tar.gz
          if-no-files-found: error

      - name: Login to GHCR
        env:
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GITHUB_ACTOR}" --password-stdin

      - name: Build & push GHCR image
        run: |
          set -euo pipefail
          VERSION_RAW="${{ steps.vars.outputs.version_raw }}"
          VERSION="${{ steps.vars.outputs.version }}"
          owner_lower="$(echo "${GITHUB_REPOSITORY_OWNER}" | tr '[:upper:]' '[:lower:]')"
          image="ghcr.io/${owner_lower}/${IMAGE_NAME}"

          docker build -f docker/jetson/Dockerfile.jetson \
            -t "${image}:${VERSION_RAW}" \
            -t "${image}:${VERSION}" \
            -t "${image}:latest" \
            .

          docker push "${image}:${VERSION_RAW}"
          docker push "${image}:${VERSION}"
          docker push "${image}:latest"

      - name: Ensure GHCR package is public
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          package="${IMAGE_NAME}"
          # Package owner is the current user (not org)
          gh api --method PUT "/user/packages/container/${package}/visibility" -f visibility=public

      - name: Collect GHCR digests (RepoDigests)
        run: |
          set -euo pipefail
          VERSION_RAW="${{ steps.vars.outputs.version_raw }}"
          VERSION="${{ steps.vars.outputs.version }}"
          owner_lower="$(echo "${GITHUB_REPOSITORY_OWNER}" | tr '[:upper:]' '[:lower:]')"
          image="ghcr.io/${owner_lower}/${IMAGE_NAME}"

          out_dir="dist/digests"
          mkdir -p "${out_dir}"

          # Pull to make sure RepoDigests is populated locally
          docker pull "${image}:${VERSION_RAW}"

          docker inspect --format '{{range .RepoDigests}}{{println .}}{{end}}' "${image}:${VERSION_RAW}" \
            > "${out_dir}/ghcr-digests-${VERSION}-${PLATFORM}.txt"
          cat "${out_dir}/ghcr-digests-${VERSION}-${PLATFORM}.txt"

      - name: Upload GHCR digest artifact
        uses: actions/upload-artifact@v4
        with:
          name: ghcr-digests-${{ steps.vars.outputs.version_raw }}-${{ env.PLATFORM }}
          path: dist/digests/ghcr-digests-${{ steps.vars.outputs.version }}-${{ env.PLATFORM }}.txt
          if-no-files-found: error

  publish-release-assets:
    name: Publish Release assets (.sha256 / SHA256SUMS / SBOM)
    needs: [build-jetson-arm64]
    runs-on: ubuntu-latest
    env:
      PLATFORM: jetson-arm64
      VERSION_RAW: ${{ github.ref_name }}
    steps:
      - name: Resolve version strings
        id: vars
        run: |
          set -euo pipefail
          version_raw="${VERSION_RAW}"
          version="${version_raw#v}"
          echo "version_raw=${version_raw}" >> "${GITHUB_OUTPUT}"
          echo "version=${version}" >> "${GITHUB_OUTPUT}"

      - name: Download tarball artifact
        uses: actions/download-artifact@v4
        with:
          name: magicbox-update-${{ steps.vars.outputs.version_raw }}-${{ env.PLATFORM }}
          path: dist

      - name: Download GHCR digest artifact
        uses: actions/download-artifact@v4
        with:
          name: ghcr-digests-${{ steps.vars.outputs.version_raw }}-${{ env.PLATFORM }}
          path: dist/digests

      - name: Generate SBOM (CycloneDX JSON) from tarball content
        run: |
          set -euo pipefail
          VERSION="${{ steps.vars.outputs.version }}"
          tarball="dist/magicbox-update-${VERSION}-${PLATFORM}.tar.gz"
          extract_dir="dist/extracted-${PLATFORM}"
          rm -rf "${extract_dir}"
          mkdir -p "${extract_dir}"
          tar -xzf "${tarball}" -C "${extract_dir}"

          # Install syft
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

          sbom="dist/sbom-${VERSION}-${PLATFORM}.cdx.json"
          syft "dir:${extract_dir}" -o cyclonedx-json > "${sbom}"

      - name: Generate per-asset SHA256 + SHA256SUMS
        run: |
          set -euo pipefail
          VERSION="${{ steps.vars.outputs.version }}"
          cd dist

          tarball="magicbox-update-${VERSION}-${PLATFORM}.tar.gz"
          sbom="sbom-${VERSION}-${PLATFORM}.cdx.json"

          sha256sum "${tarball}" > "${tarball}.sha256"
          sha256sum "${sbom}" > "${sbom}.sha256"

          cat > SHA256SUMS <<EOF
          $(cat "${tarball}.sha256")
          $(cat "${sbom}.sha256")
          EOF
          cp -f SHA256SUMS checksums.sha256

      - name: Upload assets to GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          fail_on_unmatched_files: true
          generate_release_notes: true
          files: |
            dist/magicbox-update-${{ steps.vars.outputs.version }}-${{ env.PLATFORM }}.tar.gz
            dist/magicbox-update-${{ steps.vars.outputs.version }}-${{ env.PLATFORM }}.tar.gz.sha256
            dist/sbom-${{ steps.vars.outputs.version }}-${{ env.PLATFORM }}.cdx.json
            dist/sbom-${{ steps.vars.outputs.version }}-${{ env.PLATFORM }}.cdx.json.sha256
            dist/SHA256SUMS
            dist/checksums.sha256
            dist/digests/ghcr-digests-${{ steps.vars.outputs.version }}-${{ env.PLATFORM }}.txt
