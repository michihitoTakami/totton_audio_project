{% extends "base.html" %}

{% block title %}{{ t.get('nav.dashboard') }} - {{ t.get('app.title') }}{% endblock %}

{% block content %}
<div x-data="dashboardData()" x-init="init()">
    <!-- Page Header -->
    <div class="page-header">
        <h1 class="page-title">{{ t.get('nav.dashboard') }}</h1>
        <p class="page-subtitle">{{ t.get('dashboard.subtitle') }}</p>
    </div>

    <!-- System Status Cards -->
    <div class="card-grid">
        <!-- Daemon Status Card -->
        <div class="status-card">
            <div class="status-card-header">
                <span class="status-icon">‚öôÔ∏è</span>
                <h3>{{ t.get('dashboard.daemon') }}</h3>
            </div>
            <div class="status-card-body">
                <div class="status-indicator" :class="status.daemon_running ? 'status-ok' : 'status-error'" x-text="status.daemon_running ? '{{ t.get('dashboard.status.running') }}' : '{{ t.get('dashboard.status.stopped') }}'">
                </div>
            </div>
        </div>

        <!-- EQ Status Card -->
        <div class="status-card">
            <div class="status-card-header">
                <span class="status-icon">üéöÔ∏è</span>
                <h3>{{ t.get('dashboard.eq') }}</h3>
            </div>
            <div class="status-card-body">
                <div class="status-indicator" :class="status.eq_active ? 'status-ok' : 'status-off'" x-text="status.eq_active ? '{{ t.get('dashboard.status.on') }}' : '{{ t.get('dashboard.status.off') }}'">
                </div>
            </div>
        </div>

        <!-- Crossfeed Status Card -->
        <div class="status-card">
            <div class="status-card-header">
                <span class="status-icon">üéß</span>
                <h3>{{ t.get('dashboard.crossfeed') }}</h3>
            </div>
            <div class="status-card-body">
                <div class="status-indicator" :class="status.crossfeed_enabled ? 'status-ok' : 'status-off'" x-text="status.crossfeed_enabled ? '{{ t.get('dashboard.status.on') }}' : '{{ t.get('dashboard.status.off') }}'">
                </div>
            </div>
        </div>

        <!-- Low Latency Mode Card -->
        <div class="status-card">
            <div class="status-card-header">
                <span class="status-icon">‚ö°</span>
                <h3>{{ t.get('dashboard.low_latency') }}</h3>
            </div>
            <div class="status-card-body">
                <div class="status-indicator" :class="status.low_latency_enabled ? 'status-ok' : 'status-off'" x-text="status.low_latency_enabled ? '{{ t.get('dashboard.status.on') }}' : '{{ t.get('dashboard.status.off') }}'">
                </div>
            </div>
        </div>
    </div>

    <!-- Low Latency Mode -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.low_latency.title') }}</h2>
        <div class="card">
            <div class="toggle-container">
                <div class="toggle-label">
                    <span>{{ t.get('dashboard.low_latency.toggle') }}</span>
                    <span class="toggle-desc">{{ t.get('dashboard.low_latency.exclusive') }}</span>
                </div>
                <div class="toggle-switch" :class="{ 'active': lowLatency.enabled }" @click="toggleLowLatency"></div>
            </div>
            <div class="alert alert-warning" x-show="lowLatency.enabled && status.crossfeed_enabled">
                {{ t.get('dashboard.low_latency.warning') }}
            </div>
            <div class="info-text">
                <span class="icon">‚ÑπÔ∏è</span>{{ t.get('dashboard.low_latency.info') }}
            </div>
        </div>
    </div>

    <!-- Output Mode -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.output_mode.title') }}</h2>
        <p class="section-subtitle">{{ t.get('dashboard.output_mode.subtitle') }}</p>
        <div class="card">
            <div class="form-group">
                <label>{{ t.get('dashboard.output_mode.mode_label') }}</label>
                <select x-model="outputMode.mode" disabled>
                    <template x-for="mode in outputMode.availableModes" :key="mode">
                        <option :value="mode" x-text="mode.toUpperCase()"></option>
                    </template>
                </select>
            </div>
            <div class="form-group">
                <label>{{ t.get('dashboard.output_mode.device_label') }}</label>
                <input
                    type="text"
                    x-model="outputMode.preferredDevice"
                    placeholder="hw:USB"
                    :disabled="outputMode.loading"
                >
            </div>
            <div class="btn-row">
                <button
                    class="action-button btn-primary"
                    @click="saveOutputMode"
                    :disabled="outputMode.loading"
                >
                    <span class="action-label">{{ t.get('dashboard.output_mode.save') }}</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Phase Type Selection -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.phase_type.title') }}</h2>
        <div class="card">
            <div class="form-group">
                <label for="phaseType">{{ t.get('dashboard.phase_type.label') }}</label>
                <select id="phaseType" x-model="phaseType.selected" @change="changePhaseType">
                    <option value="minimum">{{ t.get('dashboard.phase_type.minimum') }}</option>
                    <option value="linear">{{ t.get('dashboard.phase_type.linear') }}</option>
                </select>
            </div>
            <div class="info-text">
                <span class="icon">‚ÑπÔ∏è</span>
                <span x-show="phaseType.selected === 'minimum'">{{ t.get('dashboard.phase_type.info_minimum') }}</span>
                <span x-show="phaseType.selected === 'linear'">{{ t.get('dashboard.phase_type.info_linear') }}</span>
            </div>
            <div class="alert alert-warning" x-show="phaseType.selected === 'linear' && lowLatency.enabled">
                {{ t.get('dashboard.phase_type.warning') }}
            </div>
        </div>
    </div>

    <!-- Headphone EQ (OPRA) -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.eq.title') }}</h2>
        <div class="card">
            {% set eq_page = False %}
            {% include 'components/opra_search.html' %}

            <div class="btn-row">
                <button
                    class="action-button btn-primary"
                    @click="applyEQ"
                    :disabled="!opra.selected || actionInProgress"
                >
                    <span class="action-icon">‚úì</span>
                    <span class="action-label">{{ t.get('dashboard.eq.apply') }}</span>
                </button>
                <button
                    class="action-button btn-secondary"
                    @click="deactivateEQ"
                    :disabled="actionInProgress"
                >
                    <span class="action-icon">‚úó</span>
                    <span class="action-label">{{ t.get('dashboard.eq.off') }}</span>
                </button>
            </div>

            <div class="license-note">
                {{ t.get('dashboard.eq.license') }} <a href="https://github.com/opra-project/OPRA" target="_blank" class="license-link">{{ t.get('dashboard.eq.license_link') }}</a> (CC BY-SA 4.0)
            </div>
        </div>
    </div>

    <!-- Crossfeed (HRTF) -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.crossfeed.title') }}</h2>
        <div class="card">
            <div class="toggle-container">
                <div class="toggle-label">
                    <span>{{ t.get('dashboard.crossfeed.toggle') }}</span>
                    <span class="toggle-desc">{{ t.get('dashboard.crossfeed.toggle_desc') }}</span>
                </div>
                <div class="toggle-switch" :class="{ 'active': crossfeed.enabled }" @click="toggleCrossfeed"></div>
            </div>

            <div class="form-group" style="margin-top: 16px;" x-show="crossfeed.enabled">
                <label>{{ t.get('dashboard.crossfeed.head_size') }}</label>
                <div class="head-size-group">
                    <button
                        type="button"
                        class="head-size-btn"
                        :class="{ 'active': crossfeed.headSize === 'xs' }"
                        @click="setHeadSize('xs')"
                        :disabled="!crossfeed.enabled"
                    >XS</button>
                    <button
                        type="button"
                        class="head-size-btn"
                        :class="{ 'active': crossfeed.headSize === 's' }"
                        @click="setHeadSize('s')"
                        :disabled="!crossfeed.enabled"
                    >S</button>
                    <button
                        type="button"
                        class="head-size-btn"
                        :class="{ 'active': crossfeed.headSize === 'm' }"
                        @click="setHeadSize('m')"
                        :disabled="!crossfeed.enabled"
                    >M</button>
                    <button
                        type="button"
                        class="head-size-btn"
                        :class="{ 'active': crossfeed.headSize === 'l' }"
                        @click="setHeadSize('l')"
                        :disabled="!crossfeed.enabled"
                    >L</button>
                    <button
                        type="button"
                        class="head-size-btn"
                        :class="{ 'active': crossfeed.headSize === 'xl' }"
                        @click="setHeadSize('xl')"
                        :disabled="!crossfeed.enabled"
                    >XL</button>
                </div>
            </div>

            <div class="alert alert-warning" x-show="crossfeed.enabled && lowLatency.enabled">
                {{ t.get('dashboard.crossfeed.warning') }}
            </div>

            <div class="info-text">
                <span class="icon">‚ÑπÔ∏è</span>{{ t.get('dashboard.crossfeed.info') }}
            </div>

            <div class="license-note">
                {{ t.get('dashboard.crossfeed.license') }} <a href="https://depositonce.tu-berlin.de/items/dc2a3076-a291-417e-97f0-7697e332c960" target="_blank" class="license-link">{{ t.get('dashboard.crossfeed.license_link') }}</a> (CC BY 4.0)
            </div>
        </div>
    </div>

    <!-- Quick Actions -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.quick_actions') }}</h2>
        <div class="card">
            <div class="action-grid">
                <button
                    class="action-button"
                    @click="restartDaemon"
                    :disabled="actionInProgress"
                >
                    <span class="action-icon">üîÑ</span>
                    <span class="action-label">{{ t.get('dashboard.action.restart_daemon') }}</span>
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
function dashboardData() {
    return {
        status: {
            daemon_running: false,
            eq_active: false,
            crossfeed_enabled: false,
            low_latency_enabled: false,
        },
        lowLatency: {
            enabled: false,
            loading: false,
        },
        phaseType: {
            selected: 'minimum',
            loading: false,
        },
        opra: {
            searchQuery: '',
            results: [],
            selected: null,
            eqProfiles: [],
            selectedEqId: '',
            useModernTarget: true,
            searching: false,
        },
        crossfeed: {
            enabled: false,
            headSize: 'm',
            loading: false,
        },
        outputMode: {
            mode: 'usb',
            availableModes: ['usb'],
            preferredDevice: '',
            loading: false,
        },
        messages: {
            outputSaveSuccess: "{{ t.get('dashboard.output_mode.success') }}",
            outputSaveError: "{{ t.get('dashboard.output_mode.error') }}",
        },
        actionInProgress: false,
        wsConnected: false,
        ws: null,

        init() {
            this.fetchStatus();
            this.fetchLowLatencyStatus();
            this.fetchPhaseType();
            this.fetchCrossfeedStatus();
             this.fetchOutputMode();
            // Poll status every 3 seconds
            setInterval(() => {
                this.fetchStatus();
                this.fetchLowLatencyStatus();
                this.fetchCrossfeedStatus();
            }, 3000);
        },

        async fetchStatus() {
            try {
                const response = await fetch('/status');
                if (!response.ok) throw new Error('Status fetch failed');
                const data = await response.json();
                this.status = {
                    daemon_running: data.daemon_running || false,
                    eq_active: data.eq_active || false,
                    crossfeed_enabled: data.settings?.crossfeed_enabled || false,
                    low_latency_enabled: data.settings?.low_latency_enabled || false,
                };
            } catch (error) {
                console.error('Failed to fetch status:', error);
            }
        },

        async fetchLowLatencyStatus() {
            try {
                const response = await fetch('/partitioned-convolution');
                if (!response.ok) throw new Error('Failed to fetch low latency status');
                const data = await response.json();
                this.lowLatency.enabled = data.enabled || false;
            } catch (error) {
                console.error('Failed to fetch low latency status:', error);
            }
        },

        async fetchPhaseType() {
            try {
                const response = await fetch('/daemon/phase-type');
                if (!response.ok) throw new Error('Failed to fetch phase type');
                const data = await response.json();
                this.phaseType.selected = data.phase_type || 'minimum';
            } catch (error) {
                console.error('Failed to fetch phase type:', error);
            }
        },

        async saveOutputMode() {
            if (this.outputMode.loading) return;
            this.outputMode.loading = true;
            try {
                const payload = {
                    mode: this.outputMode.mode,
                    options: {
                        usb: {
                            preferred_device: this.outputMode.preferredDevice,
                        },
                    },
                };
                const response = await fetch('/api/output/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await response.json();
                if (!response.ok || data.success === false) {
                    throw new Error(data.detail?.message || data.message || 'Failed');
                }
                await this.fetchOutputMode();
                this.showToast(
                    data.message || this.messages.outputSaveSuccess,
                    'success'
                );
            } catch (error) {
                console.error('Failed to save output mode:', error);
                this.showToast(this.messages.outputSaveError, 'error');
            } finally {
                this.outputMode.loading = false;
            }
        },

        async fetchCrossfeedStatus() {
            try {
                const response = await fetch('/crossfeed/status');
                if (!response.ok) throw new Error('Failed to fetch crossfeed status');
                const data = await response.json();
                this.crossfeed.enabled = data.enabled || false;
                this.crossfeed.headSize = data.head_size || 'm';
            } catch (error) {
                console.error('Failed to fetch crossfeed status:', error);
            }
        },

        async fetchOutputMode() {
            try {
                const response = await fetch('/api/output/mode');
                if (!response.ok) throw new Error('Failed to fetch output mode');
                const data = await response.json();
                this.outputMode.mode = data.mode || 'usb';
                this.outputMode.availableModes = data.available_modes || ['usb'];
                this.outputMode.preferredDevice =
                    data.options?.usb?.preferred_device ?? '';
            } catch (error) {
                console.error('Failed to fetch output mode:', error);
            }
        },

        async toggleLowLatency() {
            if (this.lowLatency.loading) return;

            this.lowLatency.loading = true;
            try {
                const newState = !this.lowLatency.enabled;
                const response = await fetch('/partitioned-convolution', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: newState }),
                });

                if (!response.ok) throw new Error('Failed to toggle low latency mode');

                const result = await response.json();
                // ApiResponse format: { success, message, data: { partitioned_convolution: {...} } }
                this.lowLatency.enabled = result.data?.partitioned_convolution?.enabled ?? newState;
                this.showToast(result.message || '‰ΩéÈÅÖÂª∂„É¢„Éº„Éâ„ÇíÂàá„ÇäÊõø„Åà„Åæ„Åó„Åü', 'success');

                // Refresh status
                await this.fetchStatus();
            } catch (error) {
                console.error('Failed to toggle low latency:', error);
                this.showToast('‰ΩéÈÅÖÂª∂„É¢„Éº„Éâ„ÅÆÂàá„ÇäÊõø„Åà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                this.lowLatency.loading = false;
            }
        },

        async changePhaseType() {
            if (this.phaseType.loading) return;

            this.phaseType.loading = true;
            try {
                const response = await fetch('/daemon/phase-type', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ phase_type: this.phaseType.selected }),
                });

                if (!response.ok) throw new Error('Failed to change phase type');

                const data = await response.json();
                this.showToast(data.message || '‰ΩçÁõ∏„Çø„Ç§„Éó„ÇíÂ§âÊõ¥„Åó„Åæ„Åó„Åü', 'success');
            } catch (error) {
                console.error('Failed to change phase type:', error);
                this.showToast('‰ΩçÁõ∏„Çø„Ç§„Éó„ÅÆÂ§âÊõ¥„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                this.phaseType.loading = false;
            }
        },

        async searchOPRA() {
            if (!this.opra.searchQuery || this.opra.searchQuery.length < 2) {
                this.opra.results = [];
                return;
            }

            this.opra.searching = true;
            try {
                const response = await fetch(`/opra/search?q=${encodeURIComponent(this.opra.searchQuery)}`);
                if (!response.ok) throw new Error('Search failed');
                const data = await response.json();
                this.opra.results = data.results || [];
            } catch (error) {
                console.error('Failed to search OPRA:', error);
                this.opra.results = [];
            } finally {
                this.opra.searching = false;
            }
        },

        selectHeadphone(result) {
            this.opra.selected = result;
            this.opra.results = [];
            this.opra.searchQuery = result.name;
            // eq_profiles is an array of {id, name, author}
            this.opra.eqProfiles = result.eq_profiles || [];
            this.opra.selectedEqId = this.opra.eqProfiles[0]?.id || '';
        },

        async applyEQ() {
            if (!this.opra.selected || this.actionInProgress) return;

            this.actionInProgress = true;
            try {
                const eqId = this.opra.selectedEqId || this.opra.eqProfiles[0]?.id;
                if (!eqId) {
                    throw new Error('No EQ profile selected');
                }

                const endpoint = `/opra/apply/${encodeURIComponent(eqId)}?apply_correction=${this.opra.useModernTarget}`;
                const response = await fetch(endpoint, {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Failed to apply EQ');

                const data = await response.json();
                this.showToast(data.message || 'EQ„ÇíÈÅ©Áî®„Åó„Åæ„Åó„Åü', 'success');
                await this.fetchStatus();
            } catch (error) {
                console.error('Failed to apply EQ:', error);
                this.showToast('EQ„ÅÆÈÅ©Áî®„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                this.actionInProgress = false;
            }
        },

        async deactivateEQ() {
            if (this.actionInProgress) return;

            this.actionInProgress = true;
            try {
                const response = await fetch('/eq/deactivate', {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Failed to deactivate EQ');

                const data = await response.json();
                this.showToast(data.message || 'EQ„ÇíÁÑ°ÂäπÂåñ„Åó„Åæ„Åó„Åü', 'success');
                await this.fetchStatus();
            } catch (error) {
                console.error('Failed to deactivate EQ:', error);
                this.showToast('EQ„ÅÆÁÑ°ÂäπÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                this.actionInProgress = false;
            }
        },

        async toggleCrossfeed() {
            if (this.crossfeed.loading) return;

            this.crossfeed.loading = true;
            try {
                const newState = !this.crossfeed.enabled;
                const endpoint = newState ? '/crossfeed/enable' : '/crossfeed/disable';
                const response = await fetch(endpoint, {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Failed to toggle crossfeed');

                const data = await response.json();
                this.crossfeed.enabled = newState;
                this.showToast(data.message || '„ÇØ„É≠„Çπ„Éï„Ç£„Éº„Éâ„ÇíÂàá„ÇäÊõø„Åà„Åæ„Åó„Åü', 'success');
                await this.fetchStatus();
            } catch (error) {
                console.error('Failed to toggle crossfeed:', error);
                this.showToast('„ÇØ„É≠„Çπ„Éï„Ç£„Éº„Éâ„ÅÆÂàá„ÇäÊõø„Åà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                this.crossfeed.loading = false;
            }
        },

        async setHeadSize(size) {
            if (!this.crossfeed.enabled || this.crossfeed.loading) return;

            this.crossfeed.loading = true;
            try {
                const response = await fetch(`/crossfeed/size/${size}`, {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Failed to set head size');

                const data = await response.json();
                this.crossfeed.headSize = data.headSize || size;
                this.showToast(data.message || 'È†≠„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂ§âÊõ¥„Åó„Åæ„Åó„Åü', 'success');
            } catch (error) {
                console.error('Failed to set head size:', error);
                this.showToast('È†≠„ÅÆ„Çµ„Ç§„Ç∫„ÅÆÂ§âÊõ¥„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                this.crossfeed.loading = false;
            }
        },

        async restartDaemon() {
            if (this.actionInProgress) return;

            this.actionInProgress = true;
            try {
                const response = await fetch('/daemon/restart', {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Restart failed');

                const data = await response.json();
                this.showToast(data.message || '„Éá„Éº„É¢„É≥„ÇíÂÜçËµ∑Âãï„Åó„Åæ„Åó„Åü', 'success');

                // Wait and refresh status
                setTimeout(() => this.fetchStatus(), 2000);
            } catch (error) {
                console.error('Failed to restart daemon:', error);
                this.showToast('ÂÜçËµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                this.actionInProgress = false;
            }
        },

        showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                padding: 12px 20px;
                background: ${type === 'success' ? '#00ff88' : type === 'error' ? '#ff4444' : '#00d4ff'};
                color: #0a0e12;
                border-radius: 8px;
                font-weight: 600;
                z-index: 9999;
                animation: slideIn 0.3s ease;
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        },
    };
}
</script>
{% endblock %}
