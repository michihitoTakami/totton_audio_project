{% extends "base.html" %}

{% block title %}{{ t.get('nav.dashboard') }} - {{ t.get('app.title') }}{% endblock %}

{% block content %}
<div x-data="dashboardData()" x-init="init()">
    <!-- Page Header -->
    <div class="page-header">
        <h1 class="page-title">{{ t.get('nav.dashboard') }}</h1>
        <p class="page-subtitle">{{ t.get('dashboard.subtitle') }}</p>
    </div>

    <!-- System Status Cards -->
    <div class="card-grid">
        <!-- Daemon Status Card -->
        <div class="status-card">
            <div class="status-card-header">
                <span class="status-icon">âš™ï¸</span>
                <h3>{{ t.get('dashboard.daemon') }}</h3>
            </div>
            <div class="status-card-body">
                <div class="status-indicator" :class="status.daemon_running ? 'status-ok' : 'status-error'">
                    <span x-text="status.daemon_running ? '{{ t.get('dashboard.status.running') }}' : '{{ t.get('dashboard.status.stopped') }}'"></span>
                </div>
            </div>
        </div>

        <!-- EQ Status Card -->
        <div class="status-card">
            <div class="status-card-header">
                <span class="status-icon">ğŸšï¸</span>
                <h3>{{ t.get('dashboard.eq') }}</h3>
            </div>
            <div class="status-card-body">
                <div class="status-indicator" :class="status.eq_active ? 'status-ok' : 'status-off'">
                    <span x-text="status.eq_active ? '{{ t.get('dashboard.status.on') }}' : '{{ t.get('dashboard.status.off') }}'"></span>
                </div>
            </div>
        </div>

        <!-- Crossfeed Status Card -->
        <div class="status-card">
            <div class="status-card-header">
                <span class="status-icon">ğŸ§</span>
                <h3>ã‚¯ãƒ­ã‚¹ãƒ•ã‚£ãƒ¼ãƒ‰</h3>
            </div>
            <div class="status-card-body">
                <div class="status-indicator" :class="status.crossfeed_enabled ? 'status-ok' : 'status-off'">
                    <span x-text="status.crossfeed_enabled ? 'ON' : 'OFF'"></span>
                </div>
            </div>
        </div>

        <!-- Low Latency Mode Card -->
        <div class="status-card">
            <div class="status-card-header">
                <span class="status-icon">âš¡</span>
                <h3>ä½é…å»¶ãƒ¢ãƒ¼ãƒ‰</h3>
            </div>
            <div class="status-card-body">
                <div class="status-indicator" :class="status.low_latency_enabled ? 'status-ok' : 'status-off'">
                    <span x-text="status.low_latency_enabled ? 'ON' : 'OFF'"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Low Latency Mode -->
    <div class="section">
        <h2 class="section-title">âš¡ ä½é…å»¶ãƒ¢ãƒ¼ãƒ‰ (Partitioned Convolution)</h2>
        <div class="card">
            <div class="toggle-container">
                <div class="toggle-label">
                    <span>ä½é…å»¶ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ³</span>
                    <span class="toggle-desc">ã‚¯ãƒ­ã‚¹ãƒ•ã‚£ãƒ¼ãƒ‰ã¨æ’ä»–åˆ©ç”¨</span>
                </div>
                <div class="toggle-switch" :class="{ 'active': lowLatency.enabled }" @click="toggleLowLatency"></div>
            </div>
            <div class="alert alert-warning" x-show="lowLatency.enabled && status.crossfeed_enabled">
                âš ï¸ ã‚¯ãƒ­ã‚¹ãƒ•ã‚£ãƒ¼ãƒ‰ã¯ä½é…å»¶ãƒ¢ãƒ¼ãƒ‰ã§ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚
            </div>
            <div class="info-text">
                <span class="icon">â„¹ï¸</span>32kã‚¿ãƒƒãƒ—ã®é«˜é€Ÿãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ³ã§è¶…ä½é…å»¶ã‚’å®Ÿç¾ã—ã¾ã™ã€‚
            </div>
        </div>
    </div>

    <!-- Phase Type Selection -->
    <div class="section">
        <h2 class="section-title">ğŸŒŠ ä½ç›¸ã‚¿ã‚¤ãƒ—</h2>
        <div class="card">
            <div class="form-group">
                <label for="phaseType">Filter Phase</label>
                <select id="phaseType" x-model="phaseType.selected" @change="changePhaseType">
                    <option value="minimum">Minimum Phase (æ¨å¥¨)</option>
                    <option value="hybrid">Hybrid Phase (150Hzä»¥ä¸‹æœ€å° / 150Hzä»¥ä¸Šç·šå½¢)</option>
                </select>
            </div>
            <div class="info-text">
                <span class="icon">â„¹ï¸</span>
                <span x-show="phaseType.selected === 'minimum'">å…¨å¸¯åŸŸã‚’æœ€å°ä½ç›¸ã§å‡¦ç†ï¼ˆæœ€å°ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ï¼‰</span>
                <span x-show="phaseType.selected === 'hybrid'">150Hzä»¥ä¸‹ã¯æœ€å°ä½ç›¸ã€150Hzä»¥ä¸Šã¯ç·šå½¢ä½ç›¸ï¼ˆç´„6.7msæ•´åˆ—ï¼‰ã§å‡¦ç†</span>
            </div>
            <div class="alert alert-warning" x-show="phaseType.selected === 'hybrid' && lowLatency.enabled">
                âš ï¸ ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä½ç›¸ã¯ç´„6.7msã®æ•´åˆ—ãƒ‡ã‚£ãƒ¬ã‚¤ãŒç™ºç”Ÿã—ã€ä½é…å»¶ãƒ¢ãƒ¼ãƒ‰ã¨ã¯ä½µç”¨ã§ãã¾ã›ã‚“ã€‚
            </div>
        </div>
    </div>

    <!-- Headphone EQ (OPRA) -->
    <div class="section">
        <h2 class="section-title">ğŸšï¸ ãƒ˜ãƒƒãƒ‰ãƒ›ãƒ³EQ (OPRA)</h2>
        <div class="card">
            <div class="form-group">
                <label for="opraSearch">Search Headphones</label>
                <input
                    type="text"
                    id="opraSearch"
                    class="search-input"
                    placeholder="e.g. HD650, DT770, AirPods..."
                    x-model="opra.searchQuery"
                    @input="searchOPRA"
                >
            </div>

            <!-- Search Results -->
            <div class="opra-results" x-show="opra.results.length > 0" style="max-height: 300px; overflow-y: auto; margin-top: 12px;">
                <template x-for="result in opra.results" :key="result.name">
                    <div class="opra-result-item" @click="selectHeadphone(result)">
                        <div class="opra-result-name" x-text="result.name"></div>
                        <div class="opra-result-vendor" x-text="result.vendor"></div>
                    </div>
                </template>
            </div>

            <!-- Selected Headphone -->
            <div class="opra-selected" x-show="opra.selected" style="margin-top: 16px;">
                <div class="opra-selected-name" x-text="opra.selected?.name"></div>
                <div class="opra-selected-vendor" x-text="opra.selected?.vendor"></div>

                <div class="form-group" style="margin-top: 12px;" x-show="opra.eqOptions.length > 0">
                    <label for="opraEqSelect">EQãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³</label>
                    <select id="opraEqSelect" x-model="opra.selectedEq">
                        <template x-for="eq in opra.eqOptions" :key="eq">
                            <option :value="eq" x-text="eq"></option>
                        </template>
                    </select>
                </div>

                <label class="checkbox-label" style="margin-top: 12px;">
                    <input type="checkbox" x-model="opra.useModernTarget">
                    <span>Modern Target (KB5000_7)</span>
                </label>
                <div class="info-text" style="margin-left: 24px;">
                    æœ€æ–°ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚«ãƒ¼ãƒ–ã«è£œæ­£
                </div>
            </div>

            <div class="btn-row">
                <button
                    class="action-button btn-primary"
                    @click="applyEQ"
                    :disabled="!opra.selected || actionInProgress"
                >
                    <span class="action-icon">âœ“</span>
                    <span class="action-label">Apply EQ</span>
                </button>
                <button
                    class="action-button btn-secondary"
                    @click="deactivateEQ"
                    :disabled="actionInProgress"
                >
                    <span class="action-icon">âœ—</span>
                    <span class="action-label">EQ Off</span>
                </button>
            </div>

            <div class="license-note">
                EQ data: <a href="https://github.com/opra-project/OPRA" target="_blank" class="license-link">OPRA Project</a> (CC BY-SA 4.0)
            </div>
        </div>
    </div>

    <!-- Crossfeed (HRTF) -->
    <div class="section">
        <h2 class="section-title">ğŸ§ ã‚¯ãƒ­ã‚¹ãƒ•ã‚£ãƒ¼ãƒ‰ (HRTF)</h2>
        <div class="card">
            <div class="toggle-container">
                <div class="toggle-label">
                    <span>ã‚¯ãƒ­ã‚¹ãƒ•ã‚£ãƒ¼ãƒ‰</span>
                    <span class="toggle-desc">ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒªã‚¹ãƒ‹ãƒ³ã‚°ã‚’å†ç¾</span>
                </div>
                <div class="toggle-switch" :class="{ 'active': crossfeed.enabled }" @click="toggleCrossfeed"></div>
            </div>

            <div class="form-group" style="margin-top: 16px;" x-show="crossfeed.enabled">
                <label>é ­ã®ã‚µã‚¤ã‚º:</label>
                <div class="head-size-group">
                    <button
                        type="button"
                        class="head-size-btn"
                        :class="{ 'active': crossfeed.headSize === 'xs' }"
                        @click="setHeadSize('xs')"
                        :disabled="!crossfeed.enabled"
                    >XS</button>
                    <button
                        type="button"
                        class="head-size-btn"
                        :class="{ 'active': crossfeed.headSize === 's' }"
                        @click="setHeadSize('s')"
                        :disabled="!crossfeed.enabled"
                    >S</button>
                    <button
                        type="button"
                        class="head-size-btn"
                        :class="{ 'active': crossfeed.headSize === 'm' }"
                        @click="setHeadSize('m')"
                        :disabled="!crossfeed.enabled"
                    >M</button>
                    <button
                        type="button"
                        class="head-size-btn"
                        :class="{ 'active': crossfeed.headSize === 'l' }"
                        @click="setHeadSize('l')"
                        :disabled="!crossfeed.enabled"
                    >L</button>
                    <button
                        type="button"
                        class="head-size-btn"
                        :class="{ 'active': crossfeed.headSize === 'xl' }"
                        @click="setHeadSize('xl')"
                        :disabled="!crossfeed.enabled"
                    >XL</button>
                </div>
            </div>

            <div class="alert alert-warning" x-show="crossfeed.enabled && lowLatency.enabled">
                âš ï¸ ã‚¯ãƒ­ã‚¹ãƒ•ã‚£ãƒ¼ãƒ‰ã¯ä½é…å»¶ãƒ¢ãƒ¼ãƒ‰ã¨ä½µç”¨ã§ãã¾ã›ã‚“ã€‚
            </div>

            <div class="info-text">
                <span class="icon">â„¹ï¸</span>æ­£ä¸‰è§’å½¢é…ç½®ï¼ˆÂ±30Â°ï¼‰ã§ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒªã‚¹ãƒ‹ãƒ³ã‚°ã‚’å†ç¾
            </div>

            <div class="license-note">
                HRTF data: <a href="https://depositonce.tu-berlin.de/items/dc2a3076-a291-417e-97f0-7697e332c960" target="_blank" class="license-link">HUTUBS, TU Berlin</a> (CC BY 4.0)
            </div>
        </div>
    </div>

    <!-- Quick Actions -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.quick_actions') }}</h2>
        <div class="card">
            <div class="action-grid">
                <button
                    class="action-button"
                    @click="restartDaemon"
                    :disabled="actionInProgress"
                >
                    <span class="action-icon">ğŸ”„</span>
                    <span class="action-label">{{ t.get('dashboard.action.restart_daemon') }}</span>
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
function dashboardData() {
    return {
        status: {
            daemon_running: false,
            eq_active: false,
            crossfeed_enabled: false,
            low_latency_enabled: false,
        },
        lowLatency: {
            enabled: false,
            loading: false,
        },
        phaseType: {
            selected: 'minimum',
            loading: false,
        },
        opra: {
            searchQuery: '',
            results: [],
            selected: null,
            eqOptions: [],
            selectedEq: '',
            useModernTarget: true,
            searching: false,
        },
        crossfeed: {
            enabled: false,
            headSize: 'm',
            loading: false,
        },
        actionInProgress: false,
        wsConnected: false,
        ws: null,

        init() {
            this.fetchStatus();
            this.fetchLowLatencyStatus();
            this.fetchPhaseType();
            this.fetchCrossfeedStatus();
            // Poll status every 3 seconds
            setInterval(() => {
                this.fetchStatus();
                this.fetchLowLatencyStatus();
                this.fetchCrossfeedStatus();
            }, 3000);
        },

        async fetchStatus() {
            try {
                const response = await fetch('/status');
                if (!response.ok) throw new Error('Status fetch failed');
                const data = await response.json();
                this.status = {
                    daemon_running: data.daemon_running || false,
                    eq_active: data.eq_active || false,
                    crossfeed_enabled: data.settings?.crossfeed_enabled || false,
                    low_latency_enabled: data.settings?.low_latency_enabled || false,
                };
            } catch (error) {
                console.error('Failed to fetch status:', error);
            }
        },

        async fetchLowLatencyStatus() {
            try {
                const response = await fetch('/partitioned-convolution');
                if (!response.ok) throw new Error('Failed to fetch low latency status');
                const data = await response.json();
                this.lowLatency.enabled = data.enabled || false;
            } catch (error) {
                console.error('Failed to fetch low latency status:', error);
            }
        },

        async fetchPhaseType() {
            try {
                const response = await fetch('/daemon/phase-type');
                if (!response.ok) throw new Error('Failed to fetch phase type');
                const data = await response.json();
                this.phaseType.selected = data.phase_type || 'minimum';
            } catch (error) {
                console.error('Failed to fetch phase type:', error);
            }
        },

        async fetchCrossfeedStatus() {
            try {
                const response = await fetch('/crossfeed/status');
                if (!response.ok) throw new Error('Failed to fetch crossfeed status');
                const data = await response.json();
                this.crossfeed.enabled = data.enabled || false;
                this.crossfeed.headSize = data.head_size || 'm';
            } catch (error) {
                console.error('Failed to fetch crossfeed status:', error);
            }
        },

        async toggleLowLatency() {
            if (this.lowLatency.loading) return;

            this.lowLatency.loading = true;
            try {
                const newState = !this.lowLatency.enabled;
                const response = await fetch('/partitioned-convolution', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: newState }),
                });

                if (!response.ok) throw new Error('Failed to toggle low latency mode');

                const data = await response.json();
                this.lowLatency.enabled = data.enabled;
                this.showToast(data.message || 'ä½é…å»¶ãƒ¢ãƒ¼ãƒ‰ã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ', 'success');

                // Refresh status
                await this.fetchStatus();
            } catch (error) {
                console.error('Failed to toggle low latency:', error);
                this.showToast('ä½é…å»¶ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.lowLatency.loading = false;
            }
        },

        async changePhaseType() {
            if (this.phaseType.loading) return;

            this.phaseType.loading = true;
            try {
                const response = await fetch('/daemon/phase-type', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ phase_type: this.phaseType.selected }),
                });

                if (!response.ok) throw new Error('Failed to change phase type');

                const data = await response.json();
                this.showToast(data.message || 'ä½ç›¸ã‚¿ã‚¤ãƒ—ã‚’å¤‰æ›´ã—ã¾ã—ãŸ', 'success');
            } catch (error) {
                console.error('Failed to change phase type:', error);
                this.showToast('ä½ç›¸ã‚¿ã‚¤ãƒ—ã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.phaseType.loading = false;
            }
        },

        async searchOPRA() {
            if (!this.opra.searchQuery || this.opra.searchQuery.length < 2) {
                this.opra.results = [];
                return;
            }

            this.opra.searching = true;
            try {
                const response = await fetch(`/opra/search?query=${encodeURIComponent(this.opra.searchQuery)}`);
                if (!response.ok) throw new Error('Search failed');
                const data = await response.json();
                this.opra.results = data.results || [];
            } catch (error) {
                console.error('Failed to search OPRA:', error);
                this.opra.results = [];
            } finally {
                this.opra.searching = false;
            }
        },

        selectHeadphone(result) {
            this.opra.selected = result;
            this.opra.results = [];
            this.opra.searchQuery = result.name;
            this.opra.eqOptions = result.eq_variants || [];
            this.opra.selectedEq = this.opra.eqOptions[0] || '';
        },

        async applyEQ() {
            if (!this.opra.selected || this.actionInProgress) return;

            this.actionInProgress = true;
            try {
                const payload = {
                    headphone: this.opra.selected.name,
                    variant: this.opra.selectedEq,
                    modern_target: this.opra.useModernTarget,
                };

                const response = await fetch('/opra/apply', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });

                if (!response.ok) throw new Error('Failed to apply EQ');

                const data = await response.json();
                this.showToast(data.message || 'EQã‚’é©ç”¨ã—ã¾ã—ãŸ', 'success');
                await this.fetchStatus();
            } catch (error) {
                console.error('Failed to apply EQ:', error);
                this.showToast('EQã®é©ç”¨ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.actionInProgress = false;
            }
        },

        async deactivateEQ() {
            if (this.actionInProgress) return;

            this.actionInProgress = true;
            try {
                const response = await fetch('/eq/deactivate', {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Failed to deactivate EQ');

                const data = await response.json();
                this.showToast(data.message || 'EQã‚’ç„¡åŠ¹åŒ–ã—ã¾ã—ãŸ', 'success');
                await this.fetchStatus();
            } catch (error) {
                console.error('Failed to deactivate EQ:', error);
                this.showToast('EQã®ç„¡åŠ¹åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.actionInProgress = false;
            }
        },

        async toggleCrossfeed() {
            if (this.crossfeed.loading) return;

            this.crossfeed.loading = true;
            try {
                const newState = !this.crossfeed.enabled;
                const response = await fetch('/crossfeed/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        enabled: newState,
                        head_size: this.crossfeed.headSize,
                    }),
                });

                if (!response.ok) throw new Error('Failed to toggle crossfeed');

                const data = await response.json();
                this.crossfeed.enabled = data.enabled;
                this.showToast(data.message || 'ã‚¯ãƒ­ã‚¹ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ', 'success');
                await this.fetchStatus();
            } catch (error) {
                console.error('Failed to toggle crossfeed:', error);
                this.showToast('ã‚¯ãƒ­ã‚¹ãƒ•ã‚£ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.crossfeed.loading = false;
            }
        },

        async setHeadSize(size) {
            if (!this.crossfeed.enabled || this.crossfeed.loading) return;

            this.crossfeed.loading = true;
            try {
                const response = await fetch('/crossfeed/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        enabled: true,
                        head_size: size,
                    }),
                });

                if (!response.ok) throw new Error('Failed to set head size');

                const data = await response.json();
                this.crossfeed.headSize = size;
                this.showToast(data.message || 'é ­ã®ã‚µã‚¤ã‚ºã‚’å¤‰æ›´ã—ã¾ã—ãŸ', 'success');
            } catch (error) {
                console.error('Failed to set head size:', error);
                this.showToast('é ­ã®ã‚µã‚¤ã‚ºã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.crossfeed.loading = false;
            }
        },

        async restartDaemon() {
            if (this.actionInProgress) return;

            this.actionInProgress = true;
            try {
                const response = await fetch('/daemon/restart', {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Restart failed');

                const data = await response.json();
                this.showToast(data.message || 'ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚’å†èµ·å‹•ã—ã¾ã—ãŸ', 'success');

                // Wait and refresh status
                setTimeout(() => this.fetchStatus(), 2000);
            } catch (error) {
                console.error('Failed to restart daemon:', error);
                this.showToast('å†èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.actionInProgress = false;
            }
        },

        showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                padding: 12px 20px;
                background: ${type === 'success' ? '#00ff88' : type === 'error' ? '#ff4444' : '#00d4ff'};
                color: #0a0e12;
                border-radius: 8px;
                font-weight: 600;
                z-index: 9999;
                animation: slideIn 0.3s ease;
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        },
    };
}
</script>
{% endblock %}
