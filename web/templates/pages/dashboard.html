{% extends "base.html" %}

{% block title %}{{ t.get('nav.dashboard') }} - {{ t.get('app.title') }}{% endblock %}

{% block content %}
<div x-data="dashboardData()" x-init="init()">
    <!-- Page Header -->
    <div class="page-header">
        <h1 class="page-title">{{ t.get('nav.dashboard') }}</h1>
        <p class="page-subtitle">{{ t.get('dashboard.subtitle') }}</p>
    </div>

    <!-- System Status Cards -->
    <div class="card-grid">
        <!-- Daemon Status Card -->
        {% set status_icon = "âš™ï¸" %}
        {% set status_title = t.get('dashboard.daemon') %}
        {% set status_class = "status.daemon_running ? 'status-ok' : 'status-error'" %}
        {% set status_text = "status.daemon_running ? '{{ t.get('dashboard.status.running') }}' : '{{ t.get('dashboard.status.stopped') }}'" %}
        {% include 'components/status_card.html' %}

        <!-- EQ Status Card -->
        {% set status_icon = "ğŸšï¸" %}
        {% set status_title = t.get('dashboard.eq') %}
        {% set status_class = "status.eq_active ? 'status-ok' : 'status-off'" %}
        {% set status_text = "status.eq_active ? '{{ t.get('dashboard.status.on') }}' : '{{ t.get('dashboard.status.off') }}'" %}
        {% include 'components/status_card.html' %}

        <!-- Crossfeed Status Card -->
        {% set status_icon = "ğŸ§" %}
        {% set status_title = t.get('dashboard.crossfeed') %}
        {% set status_class = "status.crossfeed_enabled ? 'status-ok' : 'status-off'" %}
        {% set status_text = "status.crossfeed_enabled ? '{{ t.get('dashboard.status.on') }}' : '{{ t.get('dashboard.status.off') }}'" %}
        {% include 'components/status_card.html' %}

        <!-- Low Latency Mode Card -->
        {% set status_icon = "âš¡" %}
        {% set status_title = t.get('dashboard.low_latency') %}
        {% set status_class = "status.low_latency_enabled ? 'status-ok' : 'status-off'" %}
        {% set status_text = "status.low_latency_enabled ? '{{ t.get('dashboard.status.on') }}' : '{{ t.get('dashboard.status.off') }}'" %}
        {% include 'components/status_card.html' %}

        <!-- TCP Input Status Card -->
        {% set status_icon = "ğŸŒ" %}
        {% set status_title = t.get('dashboard.tcp_input') %}
        {% set status_class = "tcp.telemetry.listening ? (tcp.telemetry.client_connected ? 'status-ok' : 'status-off') : 'status-error'" %}
        {% set status_text = "tcpConnectionText()" %}
        {% set status_subtext = "tcpFormatText()" %}
        {% set status_link = "/tcp-input" %}
        {% set status_link_label = t.get('dashboard.tcp_input.manage') %}
        {% set status_testid = "tcp-status-card" %}
        {% include 'components/status_card.html' %}
    </div>

    <!-- Low Latency Mode -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.low_latency.title') }}</h2>
        <div class="card">
            {% set toggle_label = t.get('dashboard.low_latency.toggle') %}
            {% set toggle_desc = t.get('dashboard.low_latency.exclusive') %}
            {% set alpine_model = "lowLatency.enabled" %}
            {% set alpine_click = "toggleLowLatency" %}
            {% include 'components/toggle_switch.html' %}
            {% set alert_type = "warning" %}
            {% set alert_show = "lowLatency.enabled && status.crossfeed_enabled" %}
            {% set alert_message = t.get('dashboard.low_latency.warning') %}
            {% include 'components/alert.html' %}
            {% set info_message = t.get('dashboard.low_latency.info') %}
            {% include 'components/info_text.html' %}
        </div>
    </div>

    <!-- Output Mode -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.output_mode.title') }}</h2>
        <p class="section-subtitle">{{ t.get('dashboard.output_mode.subtitle') }}</p>
        <div class="card">
            {% set form_label = t.get('dashboard.output_mode.mode_label') %}
            {% set form_input_type = "select" %}
            {% set form_input_model = "outputMode.mode" %}
            {% set form_input_disabled = "true" %}
            {% set form_select_options = '<template x-for="mode in outputMode.availableModes" :key="mode"><option :value="mode" x-text="mode.toUpperCase()"></option></template>' %}
            {% include 'components/form_group.html' %}
            {% set form_label = t.get('dashboard.output_mode.device_label') %}
            {% set form_input_type = "text" %}
            {% set form_input_model = "outputMode.preferredDevice" %}
            {% set form_input_placeholder = "hw:USB" %}
            {% set form_input_disabled = "outputMode.loading" %}
            {% include 'components/form_group.html' %}
            <div class="btn-row">
                {% set button_label = t.get('dashboard.output_mode.save') %}
                {% set alpine_click = "saveOutputMode" %}
                {% set button_disabled = "outputMode.loading" %}
                {% include 'components/action_button.html' %}
            </div>
        </div>
    </div>

    <!-- Phase Type Selection -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.phase_type.title') }}</h2>
        <div class="card">
            {% set form_label = t.get('dashboard.phase_type.label') %}
            {% set form_input_type = "select" %}
            {% set form_input_id = "phaseType" %}
            {% set form_input_model = "phaseType.selected" %}
            {% set form_on_change = "changePhaseType" %}
            {% set form_select_options = '<option value="minimum">' + t.get('dashboard.phase_type.minimum') + '</option><option value="linear">' + t.get('dashboard.phase_type.linear') + '</option>' %}
            {% include 'components/form_group.html' %}
            <div class="info-text">
                <span class="icon">â„¹ï¸</span>
                <span x-show="phaseType.selected === 'minimum'">{{ t.get('dashboard.phase_type.info_minimum') }}</span>
                <span x-show="phaseType.selected === 'linear'">{{ t.get('dashboard.phase_type.info_linear') }}</span>
            </div>
            {% set alert_type = "warning" %}
            {% set alert_show = "phaseType.selected === 'linear' && lowLatency.enabled" %}
            {% set alert_message = t.get('dashboard.phase_type.warning') %}
            {% include 'components/alert.html' %}
        </div>
    </div>

    <!-- Headphone EQ (OPRA) -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.eq.title') }}</h2>
        <div class="card">
            {% set eq_page = False %}
            {% include 'components/opra_search.html' %}

            <div class="btn-row">
                {% set button_label = t.get('dashboard.eq.apply') %}
                {% set button_icon = "âœ“" %}
                {% set alpine_click = "applyEQ" %}
                {% set button_disabled = "!opra.selected || actionInProgress" %}
                {% include 'components/action_button.html' %}
                {% set button_label = t.get('dashboard.eq.off') %}
                {% set button_icon = "âœ—" %}
                {% set button_type = "secondary" %}
                {% set alpine_click = "deactivateEQ" %}
                {% set button_disabled = "actionInProgress" %}
                {% include 'components/action_button.html' %}
            </div>

            <div class="license-note">
                {{ t.get('dashboard.eq.license') }} <a href="https://github.com/opra-project/OPRA" target="_blank" class="license-link">{{ t.get('dashboard.eq.license_link') }}</a> (CC BY-SA 4.0)
            </div>
        </div>
    </div>

    <!-- Crossfeed (HRTF) -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.crossfeed.title') }}</h2>
        <div class="card">
            {% set toggle_label = t.get('dashboard.crossfeed.toggle') %}
            {% set toggle_desc = t.get('dashboard.crossfeed.toggle_desc') %}
            {% set alpine_model = "crossfeed.enabled" %}
            {% set alpine_click = "toggleCrossfeed" %}
            {% include 'components/toggle_switch.html' %}

            {% set selector_label = t.get('dashboard.crossfeed.head_size') %}
            {% set alpine_model = "crossfeed.headSize" %}
            {% set alpine_click = "setHeadSize" %}
            {% set alpine_disabled = "!crossfeed.enabled" %}
            {% set alpine_show = "crossfeed.enabled" %}
            {% set form_group_style = "margin-top: 16px;" %}
            {% include 'components/size_selector.html' %}

            {% set alert_type = "warning" %}
            {% set alert_show = "crossfeed.enabled && lowLatency.enabled" %}
            {% set alert_message = t.get('dashboard.crossfeed.warning') %}
            {% include 'components/alert.html' %}

            {% set info_message = t.get('dashboard.crossfeed.info') %}
            {% include 'components/info_text.html' %}

            <div class="license-note">
                {{ t.get('dashboard.crossfeed.license') }} <a href="https://depositonce.tu-berlin.de/items/dc2a3076-a291-417e-97f0-7697e332c960" target="_blank" class="license-link">{{ t.get('dashboard.crossfeed.license_link') }}</a> (CC BY 4.0)
            </div>
        </div>
    </div>

    <!-- Quick Actions -->
    <div class="section">
        <h2 class="section-title">{{ t.get('dashboard.quick_actions') }}</h2>
        <div class="card">
            <div class="action-grid">
                {% set button_label = t.get('dashboard.action.restart_daemon') %}
                {% set button_icon = "ğŸ”„" %}
                {% set alpine_click = "restartDaemon" %}
                {% set button_disabled = "actionInProgress" %}
                {% include 'components/action_button.html' %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
function dashboardData() {
    return {
        status: {
            daemon_running: false,
            eq_active: false,
            crossfeed_enabled: false,
            low_latency_enabled: false,
        },
        tcp: {
            settings: {
                bind_address: '',
                port: 0,
                buffer_size_bytes: 0,
            },
            telemetry: {
                listening: false,
                client_connected: false,
                last_header: null,
            },
            updatedAt: null,
        },
        tcpLabels: {
            connected: "{{ t.get('tcp.status.connected') }}",
            listening: "{{ t.get('tcp.status.listening') }}",
            stopped: "{{ t.get('tcp.status.stopped') }}",
            unknown: "{{ t.get('tcp.status.unknown') }}",
        },
        lowLatency: {
            enabled: false,
            loading: false,
        },
        phaseType: {
            selected: 'minimum',
            loading: false,
        },
        opra: {
            searchQuery: '',
            results: [],
            selected: null,
            eqProfiles: [],
            selectedEqId: '',
            useModernTarget: true,
            searching: false,
        },
        crossfeed: {
            enabled: false,
            headSize: 'm',
            loading: false,
        },
        outputMode: {
            mode: 'usb',
            availableModes: ['usb'],
            preferredDevice: '',
            loading: false,
        },
        messages: {
            outputSaveSuccess: "{{ t.get('dashboard.output_mode.success') }}",
            outputSaveError: "{{ t.get('dashboard.output_mode.error') }}",
        },
        actionInProgress: false,
        wsConnected: false,
        ws: null,

        init() {
            this.fetchStatus();
            this.fetchLowLatencyStatus();
            this.fetchPhaseType();
            this.fetchCrossfeedStatus();
            this.fetchTcpStatus();
            this.fetchOutputMode();
            // Poll status every 3 seconds
            setInterval(() => {
                this.fetchStatus();
                this.fetchLowLatencyStatus();
                this.fetchCrossfeedStatus();
                this.fetchTcpStatus();
            }, 3000);
        },

        async fetchStatus() {
            try {
                const response = await fetch('/status');
                if (!response.ok) throw new Error('Status fetch failed');
                const data = await response.json();
                this.status.daemon_running = data.daemon_running || false;
                this.status.eq_active = data.eq_active || false;
                this.status.crossfeed_enabled = data.settings?.crossfeed_enabled || false;
                if (typeof data.settings?.low_latency_enabled === 'boolean') {
                    this.status.low_latency_enabled = data.settings.low_latency_enabled;
                }
            } catch (error) {
                console.error('Failed to fetch status:', error);
            }
        },

        formatNumber(value) {
            if (value === null || value === undefined) {
                return 'â€”';
            }
            const num = Number(value);
            return Number.isFinite(num) ? num.toLocaleString() : 'â€”';
        },

        async fetchTcpStatus() {
            try {
                const response = await fetch('/api/tcp-input/status');
                if (!response.ok) throw new Error('Failed to fetch TCP input status');
                const data = await response.json();
                if (data.settings) {
                    this.tcp.settings = data.settings;
                }
                if (data.telemetry) {
                    this.tcp.telemetry = data.telemetry;
                } else if (typeof data === 'object') {
                    this.tcp.telemetry = data;
                }
                this.tcp.updatedAt = Date.now();
            } catch (error) {
                console.error('Failed to fetch TCP input status:', error);
            }
        },

        async fetchLowLatencyStatus() {
            try {
                const response = await fetch('/partitioned-convolution');
                if (!response.ok) throw new Error('Failed to fetch low latency status');
                const data = await response.json();
                this.lowLatency.enabled = data.enabled ?? false;
                this.status.low_latency_enabled = this.lowLatency.enabled;
            } catch (error) {
                console.error('Failed to fetch low latency status:', error);
            }
        },

        async fetchPhaseType() {
            try {
                const response = await fetch('/daemon/phase-type');
                if (!response.ok) throw new Error('Failed to fetch phase type');
                const data = await response.json();
                this.phaseType.selected = data.phase_type || 'minimum';
            } catch (error) {
                console.error('Failed to fetch phase type:', error);
            }
        },

        async saveOutputMode() {
            if (this.outputMode.loading) return;
            this.outputMode.loading = true;
            try {
                const payload = {
                    mode: this.outputMode.mode,
                    options: {
                        usb: {
                            preferred_device: this.outputMode.preferredDevice,
                        },
                    },
                };
                const response = await fetch('/api/output/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await response.json();
                if (!response.ok || data.success === false) {
                    throw new Error(data.detail?.message || data.message || 'Failed');
                }
                await this.fetchOutputMode();
                this.showToast(
                    data.message || this.messages.outputSaveSuccess,
                    'success'
                );
            } catch (error) {
                console.error('Failed to save output mode:', error);
                this.showToast(this.messages.outputSaveError, 'error');
            } finally {
                this.outputMode.loading = false;
            }
        },

        async fetchCrossfeedStatus() {
            try {
                const response = await fetch('/crossfeed/status');
                if (!response.ok) throw new Error('Failed to fetch crossfeed status');
                const data = await response.json();
                this.crossfeed.enabled = data.enabled || false;
                this.crossfeed.headSize = data.head_size || 'm';
            } catch (error) {
                console.error('Failed to fetch crossfeed status:', error);
            }
        },

        async fetchOutputMode() {
            try {
                const response = await fetch('/api/output/mode');
                if (!response.ok) throw new Error('Failed to fetch output mode');
                const data = await response.json();
                this.outputMode.mode = data.mode || 'usb';
                this.outputMode.availableModes = data.available_modes || ['usb'];
                this.outputMode.preferredDevice =
                    data.options?.usb?.preferred_device ?? '';
            } catch (error) {
                console.error('Failed to fetch output mode:', error);
            }
        },

        tcpConnectionText() {
            if (this.tcp.telemetry.listening) {
                return this.tcp.telemetry.client_connected
                    ? this.tcpLabels.connected
                    : this.tcpLabels.listening;
            }
            return this.tcpLabels.stopped;
        },

        tcpFormatText() {
            const header = this.tcp.telemetry?.last_header || {};
            const rate = Number(header.sample_rate || 0);
            const channels = Number(header.channels || 0);
            const fmt = header.format;
            if (rate > 0 && channels > 0 && fmt) {
                return `${this.formatNumber(rate)} Hz Â· ${channels}ch Â· ${fmt}`;
            }
            if (rate > 0 && channels > 0) {
                return `${this.formatNumber(rate)} Hz Â· ${channels}ch`;
            }
            return this.tcpLabels.unknown;
        },

        async toggleLowLatency() {
            if (this.lowLatency.loading) return;

            this.lowLatency.loading = true;
            try {
                const newState = !this.lowLatency.enabled;
                const response = await fetch('/partitioned-convolution', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: newState }),
                });

                if (!response.ok) throw new Error('Failed to toggle low latency mode');

                const result = await response.json();
                // ApiResponse format: { success, message, data: { partitioned_convolution: {...} } }
                this.lowLatency.enabled =
                    result.data?.partitioned_convolution?.enabled ?? newState;
                this.status.low_latency_enabled = this.lowLatency.enabled;
                this.showToast(result.message || 'ä½é…å»¶ãƒ¢ãƒ¼ãƒ‰ã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ', 'success');

                // Refresh status
                await this.fetchStatus();
            } catch (error) {
                console.error('Failed to toggle low latency:', error);
                this.showToast('ä½é…å»¶ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.lowLatency.loading = false;
            }
        },

        async changePhaseType() {
            if (this.phaseType.loading) return;

            this.phaseType.loading = true;
            try {
                const response = await fetch('/daemon/phase-type', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ phase_type: this.phaseType.selected }),
                });

                if (!response.ok) throw new Error('Failed to change phase type');

                const data = await response.json();
                this.showToast(data.message || 'ä½ç›¸ã‚¿ã‚¤ãƒ—ã‚’å¤‰æ›´ã—ã¾ã—ãŸ', 'success');
            } catch (error) {
                console.error('Failed to change phase type:', error);
                this.showToast('ä½ç›¸ã‚¿ã‚¤ãƒ—ã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.phaseType.loading = false;
            }
        },

        async searchOPRA() {
            if (!this.opra.searchQuery || this.opra.searchQuery.length < 2) {
                this.opra.results = [];
                return;
            }

            this.opra.searching = true;
            try {
                const response = await fetch(`/opra/search?q=${encodeURIComponent(this.opra.searchQuery)}`);
                if (!response.ok) throw new Error('Search failed');
                const data = await response.json();
                this.opra.results = data.results || [];
            } catch (error) {
                console.error('Failed to search OPRA:', error);
                this.opra.results = [];
            } finally {
                this.opra.searching = false;
            }
        },

        selectHeadphone(result) {
            this.opra.selected = result;
            this.opra.results = [];
            this.opra.searchQuery = result.name;
            // eq_profiles is an array of {id, name, author}
            this.opra.eqProfiles = result.eq_profiles || [];
            this.opra.selectedEqId = this.opra.eqProfiles[0]?.id || '';
        },

        async applyEQ() {
            if (!this.opra.selected || this.actionInProgress) return;

            this.actionInProgress = true;
            let needsRestart = false;
            try {
                const eqId = this.opra.selectedEqId || this.opra.eqProfiles[0]?.id;
                if (!eqId) {
                    throw new Error('No EQ profile selected');
                }

                const endpoint = `/opra/apply/${encodeURIComponent(eqId)}?apply_correction=${this.opra.useModernTarget}`;
                const response = await fetch(endpoint, {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Failed to apply EQ');

                const data = await response.json();
                needsRestart = Boolean(data.success && data.restart_required);
                this.showToast(
                    data.message || 'EQã‚’é©ç”¨ã—ã¾ã—ãŸ',
                    data.success ? 'success' : 'error'
                );
                if (data.success) {
                    await this.fetchStatus();
                }
            } catch (error) {
                console.error('Failed to apply EQ:', error);
                this.showToast('EQã®é©ç”¨ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.actionInProgress = false;
                if (needsRestart) {
                    await this.restartDaemon();
                }
            }
        },

        async deactivateEQ() {
            if (this.actionInProgress) return;

            this.actionInProgress = true;
            let needsRestart = false;
            try {
                const response = await fetch('/eq/deactivate', {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Failed to deactivate EQ');

                const data = await response.json();
                needsRestart = Boolean(data.success && data.restart_required);
                this.showToast(
                    data.message || 'EQã‚’ç„¡åŠ¹åŒ–ã—ã¾ã—ãŸ',
                    data.success ? 'success' : 'error'
                );
                if (data.success) {
                    await this.fetchStatus();
                }
            } catch (error) {
                console.error('Failed to deactivate EQ:', error);
                this.showToast('EQã®ç„¡åŠ¹åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.actionInProgress = false;
                if (needsRestart) {
                    await this.restartDaemon();
                }
            }
        },

        async toggleCrossfeed() {
            if (this.crossfeed.loading) return;

            this.crossfeed.loading = true;
            try {
                const newState = !this.crossfeed.enabled;
                const endpoint = newState ? '/crossfeed/enable' : '/crossfeed/disable';
                const response = await fetch(endpoint, {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Failed to toggle crossfeed');

                const data = await response.json();
                this.crossfeed.enabled = newState;
                this.showToast(data.message || 'ã‚¯ãƒ­ã‚¹ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ', 'success');
                await this.fetchStatus();
            } catch (error) {
                console.error('Failed to toggle crossfeed:', error);
                this.showToast('ã‚¯ãƒ­ã‚¹ãƒ•ã‚£ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.crossfeed.loading = false;
            }
        },

        async setHeadSize(size) {
            if (!this.crossfeed.enabled || this.crossfeed.loading) return;

            this.crossfeed.loading = true;
            try {
                const response = await fetch(`/crossfeed/size/${size}`, {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Failed to set head size');

                const data = await response.json();
                this.crossfeed.headSize = data.headSize || size;
                this.showToast(data.message || 'é ­ã®ã‚µã‚¤ã‚ºã‚’å¤‰æ›´ã—ã¾ã—ãŸ', 'success');
            } catch (error) {
                console.error('Failed to set head size:', error);
                this.showToast('é ­ã®ã‚µã‚¤ã‚ºã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.crossfeed.loading = false;
            }
        },

        async restartDaemon() {
            if (this.actionInProgress) return;

            this.actionInProgress = true;
            try {
                const response = await fetch('/daemon/restart', {
                    method: 'POST',
                });

                if (!response.ok) throw new Error('Restart failed');

                const data = await response.json();
                this.showToast(data.message || 'ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚’å†èµ·å‹•ã—ã¾ã—ãŸ', 'success');

                // Wait and refresh status
                setTimeout(() => this.fetchStatus(), 2000);
            } catch (error) {
                console.error('Failed to restart daemon:', error);
                this.showToast('å†èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            } finally {
                this.actionInProgress = false;
            }
        },
    };
}
</script>
{% endblock %}
